---
title: MySQL学习笔记——架构与历史
date: 2019-02-12 21:32:10
tags: MySQL
toc: true
---

我近期在看《高性能MySQL》，对数据库原理有了更深的认识，特此整理了学习笔记。MySQL最重要的特性是它的存储引擎架构，这种架构的设计将 Query Processing、Server Task和数据的存储/提取相分离，因此可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。

## 1 逻辑架构 ##
- 第一层是大多数基于网络的客户端/服务器的工具或服务都有的架构，比如连接处理、授权认证、安全等。
- 第二层是MySQL大多数的核心服务功能，包括查询解析、分析、优化、缓存、内置函数，以及跨存储引擎的功能：存储过程、触发器、视图等。
- 第三层是存储引擎，负责MySQL中数据的存储和提取，类似于GNU/Linux下的各种文件系统。服务器与存储引擎通信的API，屏蔽了不同存储引擎之间的差异，所以这些差异对上层的查询过程透明。存储引擎既不会解析SQL，也不会与其他存储引擎通信，只是简单地响应服务器的请求。

### 连接管理 ###
每个客户端连接都会在服务器进程中拥有一个线程，服务器会负责缓存线程，所以不需要为每个新连接都创建或销毁线程。MySQL 5.5以上的版本提供了一个API，支持Thread Pooling插件，可以用线程池中的少量线程来服务大量的连接。

### 优化与执行 ###
- 优化器：重写查询、决定表的读取顺序、选择合适的索引等。
- 索引与schema：存储引擎的某种索引，可能对一些特定的查询有优化。
- 缓存：即Query Cache，如果能从中找到SELECT对应的查询，就不必再执行查询解析、优化的整个过程，而是直接返回缓存中的结果集。

## 2 并发控制 ##
### 读写锁 ###
- 读锁read lock/共享锁shared lock：相互不阻塞。
- 写锁write lock/排他锁exclusive lock：出于安全策略，写锁会阻塞其他的写锁和读锁。

### 锁粒度 ###
只锁定需要修改的部分数据，而不是所有的资源。也就是锁定的数据量越少，系统的并发程度越高，只要相互之间不发生冲突即可。
锁的各种操作，比如获得锁、检查锁是否解除、释放锁等，都会增加系统的开销。
锁策略就是在锁的开销和数据的安全性之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度！并且MySQL支持多个存储引擎的架构！
- 表锁table lock，服务器层，这是MySQL中最基本、开销最小的锁策略，它会锁定整张表。比如，服务器为ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。
- 行级锁row lock，存储引擎层，可以最大程度地支持并发，同时也带来了最大的锁开销。

## 3 事务 ##
- Atomicity原子性：事务是一组原子性的SQL语句，一个最小工作单元，执行要么全部成功，要么全部失败。
- Consistency一致性：执行事务的前后，数据库从一个一致性的状态转换到另一个一致性的状态。
- Isolation隔离性：一个事务在最终提交之前，对其他事务是不可见的。
- Durability持久性：一旦事务提交，其所做的修改就会永久保存到数据库。

### 隔离级别 ###
同样地，较低级别的隔离通常可以执行更高的并发，系统开销也更低。
- READ UNCOMMITTED未提交读：其他事务可以读取未提交的数据，即脏读Dirty Read。
- READ COMMITTED提交读：满足“隔离性”；这是大多数据库的默认隔离级别，但MySQL不是。
- REPEATABLE READ可重复度：解决了脏读的问题，保证在同一个事务中多次读取同样记录的结果是一致的；这是MySQL的默认隔离级别。
- SERIALIZABLE可串行化：解决了幻读Phantom Read的问题，为读取的每一行数据都加锁，可能导致大量的超时和锁争用的问题。

### 死锁 ###
指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而恶性循环的现象。
死锁检测、死锁超时机制：比如，InnoDB存储引擎检测到死锁的循环依赖，立即返回一个错误；当查询的时间达到锁等待超时的设定后放弃锁请求，将持有最少行级排他锁的事务进行回滚。

### 事务日志 ###
可以提高事务的效率：存储引擎在修改表数据时只需要修改其内存拷贝，再把该修改记录到磁盘上的事务日志中，而不是每次都将修改的数据本身持久化到磁盘。预写式日志Write-Ahead Logging，修改数据需要写两次磁盘。

### MySQL事务 ###
- **自动提交AUTOCOMMIT**：每个查询都默认当作一个事务执行提交；在当前连接中，可以设置AUTOCOMMIT变量来启用或禁用自动提交模式。
- **不应该混合使用存储引擎**：事务不是由服务器层、而是由下层的存储引擎实现的，如果在事务中混合使用事务型InnoDB和非事务型MyISAM表，一旦回滚，导致非事务型的表无法撤销变更，数据库将处于不一致的状态，这种情况很难修复。
- **隐式和显式锁定**

## 4 多版本并发控制 ##
MVCC，可看作行级锁的一个变种，通过保存数据在某个时间点的快照来实现。它在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。
InnoDB-MVCC，通过在每行记录后面保存两个隐藏的列来实现：一列是行的创建时间，一列是行的过期/删除时间。存储的两列并不是实际时间，而是系统版本号：每开始一个事务，系统版本号都会递增；事务开始时的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

### 乐观锁 ###
optimistic lock

### 悲观锁 ###
pessimistic lock

## 5 存储引擎 ##

## 6 时间线 ##

## 7 开发模式 ##
